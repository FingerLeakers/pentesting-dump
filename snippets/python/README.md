## Python snippets

### TCP client
```python
import socket
host = 'google.com'
port = 80
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))
s.sendall(b"GET / HTTP/1.1\r\nHost:google.com\r\n\r\n")
response = s.recv(4096)
print(response)
```

### TCP server
```python
import socket
import threading
bind_ip = '0.0.0.0'
bind_port = 4445


def handler(client_socket):
    client_request = client_socket.recv(1024)
    print('Received {}'.format(client_request))
    client_socket.sendall(b'ACK\n')
    client_socket.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((bind_ip, bind_port))

server.listen(5)  # max backlog of connections

while True:
    client_socket, (ip, port) = server.accept()
    print("Received connection from {}:{}".format(ip, port))
    thread = threading.Thread(target=handler, args=(client_socket,))
    thread.start()
```

### BigIP decoding and encoding
```python
import struct
import sys

def decode(ip_int):
    print("[*] Decoding {}".format(ip_int))
    host, port, end = str(ip_int).split('.')
    a, b, c, d = list(i for i in struct.pack("<I", int(host)))
    ip_str = "{}.{}.{}.{}".format(a,b,c,d)
    return ip_str, port

def encode(ip_str):
    ip_bytes = bytes([int(octet) for octet in ip_str.split('.')])
    ip_int = int.from_bytes(ip_bytes, byteorder='little')
    return ip_int


if len(sys.argv) != 3 and sys.argv[1] not in ('enc', 'dec'):
    print("Usage: {} operation encoded_string".format(sys.argv[0]))
    sys.exit()

op = sys.argv[1]
s = sys.argv[2]

if op == 'enc':
    ip_int = encode(s)
    print("[*] Encoded IP: {}".format(ip_int))
elif op == 'dec':
    ip_str, port = decode(s)
    print("[*] Decoded IP: {}:{}".format(ip_str,port))

```

### Scapy reading pcap
```python
from scapy.all import *

# Filtering packets based on TCP ports and payload size

transactions = []
with PcapReader('original.pcap') as pcap_reader:
    for pkt in pcap_reader:
        if pkt[TCP].dport == <destination_port>:
            if len(pkt[TCP].payload) > 6:
                transactions.append(pkt)
wrpcap('filtered.pcap', transactions)

```

### Scapy sending packet
```python
send(Ether(dst='ff:ff:ff:ff:ff:ff', src='00:01:02:03:04:05')/IP(dst='255.255.255.255', src='1.2.3.4')/TCP(dport=443,sport=12345))
```

### Fuzzing
```python
#!/usr/bin/env python3

import binascii
import datetime
import socket
import time

def send_payload(host, port, f, payload):
    sent = False
    while not sent:
        f.write(str(payload) + ":")
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            s.connect((host, port))
            s.settimeout(1.0)
            s.sendall(payload)
            sent = True
        except Exception as e:
            print("Connection refused, trying again in 5 seconds.")
            time.sleep(5)
        try:
            response = s.recv(4096)
        except Exception as e:
            f.write('No Response')
        else:
            f.write(str(response))
        finally:
            s.close()
            f.write("\n-----\n")

def bit_flipping(payload):
    for i in range(len(payload)):
        # 1 bit flip - 8 permutations per byte
        for j in range(8):
            copy = bytearray(payload)
            copy[i] = copy[i] ^ (1<<j)
            yield bytes(copy)  # ''.join(chr(c) for c in copy)

        # 2 bits flip - 7 permutations per byte
        for j in range(7):
            copy = bytearray(payload)
            copy[i] = copy[i] ^ (0b11000000 >> j)
            yield bytes(copy)  # ''.join(chr(c) for c in copy)
    
        # 4 bits flip - 5 permutations per byte
        for j in range(5):
            copy = bytearray(payload)
            copy[i] = copy[i] ^ (0b11110000 >> j)
            yield bytes(copy)  # ''.join(chr(c) for c in copy)

def byte_flipping(payload):
    # 1 byte flip
    for i in range(len(payload)):
        payload_copy = bytearray(payload)
        payload_copy[i] = payload_copy[i] ^ 0xFF
        yield payload_copy

    # 2 byte flip
    for i in range(len(payload)-1):
        payload_copy = bytearray(payload)
        payload_copy[i] = payload_copy[i] ^ 0xFF
        payload_copy[i+1] = payload_copy[i+1] ^ 0xFF
        yield payload_copy

    # 4 byte flip
    for i in range(len(payload)-3):
        payload_copy = bytearray(payload)
        payload_copy[i] = payload_copy[i] ^ 0xFF
        payload_copy[i+1] = payload_copy[i+1] ^ 0xFF
        payload_copy[i+2] = payload_copy[i+2] ^ 0xFF
        payload_copy[i+3] = payload_copy[i+3] ^ 0xFF
        yield payload_copy

def known_integers(payload):

    known_2_byte_int = (
        bytearray(b'\x01\x00'),  # 256 be
        bytearray(b'\x00\x01'),  # 256 le
        bytearray(b'\x04\x00'),  # 1024 be
        bytearray(b'\x00\x04'),  # 1024 le
        bytearray(b'\x10\x00'),  # 4096 be
        bytearray(b'\x00\x10'),  # 4096 le
    )

    for i in range(len(payload)-1):
        for known_int in known_2_byte_int:
            payload_copy = bytearray(payload)
            yield payload_copy[:i] + known_int + payload_copy[i+2:]


    known_8_byte_int = (
        bytearray(b'\x7f\xff\xff\xff\xff\xff\xff\xff'),  # python max_int be
        bytearray(b'\x7f\xff\xff\xff\xff\xff\xff\xfe'),  # python max int -1 be
        bytearray(b'\xff\xff\xff\xff\xff\xff\xff\x7f'),  # python max_int le
        bytearray(b'\xfe\xff\xff\xff\xff\xff\xff\x7f'),  # python max_int -1 le
    )
    
    for i in range(len(payload)-7):
        for known_int in known_8_byte_int:
            payload_copy = bytearray(payload)
            yield payload_copy[:i] + known_int + payload_copy[i+8:]

def insert_in_between_bytes(payload, character=0x41):
    for i in range(len(payload)):
        payload = bytearray(payload)
        for inject_len in (4, 8, 16, 32, 64, 128):
            yield payload[:i] + bytearray([character]*inject_len) + payload[i:]

def msg_len_adjustment(msg):
    return (len(msg)).to_bytes(4, byteorder='big') + msg[:21] + str(len(msg)).zfill(4).encode() + msg[25:]

def all_cases(payload):
    for case in bit_flipping(payload):
        yield case
    for case in byte_flipping(payload):
        yield case
    for case in known_integers(payload):
        yield case
    for case in insert_in_between_bytes(payload):
        yield case


if __name__ == '__main__':
    host, port = '127.0.0.1', 8080
    payload = 'blablablabal'.format(now=datetime.datetime.now().strftime('%Y%m%d%H%M%S')).encode()
    with open('fuzzing_{}.txt'.format(datetime.datetime.now().strftime('%Y%m%d%H%M%S')), 'w') as f:
        for case in all_cases(payload):
            # print(bytes(case))
            send_payload(host, port, f, msg_len_adjustment(case))


```

### Fake SMTP server

```python
sudo python -m smtpd -n -c DebuggingServer localhost:25
```

### Send email

```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib


def create_plain_content(content):
    return MIMEText(content, 'plain')

def create_html_content(content):
    return MIMEText(content, 'html')

def create_attachment(filename):
    attachment = MIMEBase('application', "octet-stream")
    attachment.set_payload(open(filename, "rb").read())
    encoders.encode_base64(attachment)

    attachment.add_header('Content-Disposition', 'attachment', filename=filename)
    return attachment

def send_mail(server, from_addr, to_addr_list, subject, content, attachment=None):
    msg = MIMEMultipart('alternative')
    msg['Subject'] = subject
    msg['From'] = from_addr
    msg['To'] = ', '.join(to_addr_list)

    msg.attach(content)
    
    if attachment: msg.attach(attachment)

    s = smtplib.SMTP(server)
    s.set_debuglevel(1)

    try:
        # s.starttls()
        pass
        s.send_message(msg)
    finally:
        s.quit()
```